"use client";
import React, { useEffect, useState, useRef, useCallback } from 'react';

const Background = () => {
  const [dots, setDots] = useState([]);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const containerRef = useRef(null);
  
  // Generate dots in a breadboard-like pattern
  useEffect(() => {
    const generateDots = () => {
      const dotsArray = [];
      const spacingX = 80; // Horizontal spacing between dots
      const spacingY = 60; // Vertical spacing between dots
      const rows = Math.ceil(window.innerHeight / spacingY) + 2;
      const cols = Math.ceil(window.innerWidth / spacingX) + 2;
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          // Create irregular pattern like breadboard
          const offsetX = (row % 2) * (spacingX / 2); // Offset alternate rows
          const jitterX = (Math.random() - 0.5) * 20; // Random jitter
          const jitterY = (Math.random() - 0.5) * 15;
          
          dotsArray.push({
            id: `${row}-${col}`,
            x: col * spacingX + offsetX + jitterX,
            y: row * spacingY + jitterY,
            baseOpacity: 0.1 + Math.random() * 0.1, // Very low base opacity
            glowIntensity: 0,
            size: 2 + Math.random() * 1, // Slight size variation
          });
        }
      }
      
      setDots(dotsArray);
    };
    
    generateDots();
    
    const handleResize = () => {
      generateDots();
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  // Handle mouse movement and cursor-based glowing
  const handleMouseMove = useCallback((e) => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (rect) {
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      setMousePosition({ x: mouseX, y: mouseY });
      
      // Update dots based on distance from cursor
      setDots(prevDots => 
        prevDots.map(dot => {
          const distance = Math.sqrt(
            Math.pow(dot.x - mouseX, 2) + Math.pow(dot.y - mouseY, 2)
          );
          
          // Glow intensity based on proximity (closer = brighter)
          const maxGlowDistance = 150;
          let glowIntensity = 0;
          
          if (distance < maxGlowDistance) {
            glowIntensity = Math.max(0, (maxGlowDistance - distance) / maxGlowDistance);
            // Square the intensity for more dramatic effect
            glowIntensity = Math.pow(glowIntensity, 1.5);
          }
          
          return {
            ...dot,
            glowIntensity
          };
        })
      );
    }
  }, []);
  
  // Add mouse leave handler to fade out glows
  const handleMouseLeave = useCallback(() => {
    setDots(prevDots => 
      prevDots.map(dot => ({
        ...dot,
        glowIntensity: 0
      }))
    );
  }, []);
  
  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener('mousemove', handleMouseMove);
      container.addEventListener('mouseleave', handleMouseLeave);
      
      return () => {
        container.removeEventListener('mousemove', handleMouseMove);
        container.removeEventListener('mouseleave', handleMouseLeave);
      };
    }
  }, [handleMouseMove, handleMouseLeave]);
  
  return (
    <div 
      ref={containerRef}
      className="fixed inset-0 overflow-hidden bg-black -z-10 cursor-none"
    >
      <style jsx>{`
        .dot {
          position: absolute;
          background-color: #00ffaa;
          border-radius: 50%;
          transition: all 0.15s ease-out;
          pointer-events: none;
        }
        
        .dot::before {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 200%;
          height: 200%;
          background: radial-gradient(circle, rgba(0, 255, 170, 0.4) 0%, transparent 70%);
          border-radius: 50%;
          opacity: 0;
          transition: opacity 0.15s ease-out;
        }
        
        .dot.glowing::before {
          opacity: 1;
        }
        
        .dot.intense-glow::before {
          width: 400%;
          height: 400%;
          background: radial-gradient(circle, rgba(0, 255, 170, 0.6) 0%, rgba(0, 255, 170, 0.2) 40%, transparent 70%);
        }
        
        /* Subtle connection lines between nearby dots */
        .connection-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0.03;
          background-image: 
            radial-gradient(circle at center, rgba(0, 255, 170, 0.1) 1px, transparent 1px);
          background-size: 80px 60px;
        }
        
        /* Dark vignette effect */
        .vignette {
          position: absolute;
          inset: 0;
          background: radial-gradient(ellipse at center, transparent 20%, rgba(0, 0, 0, 0.4) 70%, rgba(0, 0, 0, 0.8) 100%);
          pointer-events: none;
        }
      `}</style>
      
      {/* Connection overlay for breadboard feel */}
      <div className="connection-overlay"></div>
      
      {/* Dots */}
      {dots.map((dot) => {
        const opacity = dot.baseOpacity + (dot.glowIntensity * 0.9);
        const size = dot.size + (dot.glowIntensity * 2);
        const isGlowing = dot.glowIntensity > 0.1;
        const isIntenseGlow = dot.glowIntensity > 0.7;
        
        return (
          <div
            key={dot.id}
            className={`dot ${isGlowing ? 'glowing' : ''} ${isIntenseGlow ? 'intense-glow' : ''}`}
            style={{
              left: `${dot.x}px`,
              top: `${dot.y}px`,
              width: `${size}px`,
              height: `${size}px`,
              opacity: opacity,
              boxShadow: isGlowing 
                ? `0 0 ${dot.glowIntensity * 20}px rgba(0, 255, 170, ${dot.glowIntensity * 0.8})` 
                : 'none',
              transform: `translate(-50%, -50%) scale(${1 + dot.glowIntensity * 0.5})`,
            }}
          />
        );
      })}
      
      {/* Vignette effect */}
      <div className="vignette"></div>
      
      {/* Cursor glow effect */}
      <div
        className="fixed pointer-events-none transition-opacity duration-300"
        style={{
          left: mousePosition.x,
          top: mousePosition.y,
          transform: 'translate(-50%, -50%)',
          width: '100px',
          height: '100px',
          background: 'radial-gradient(circle, rgba(0, 255, 170, 0.1) 0%, transparent 70%)',
          borderRadius: '50%',
          opacity: mousePosition.x > 0 ? 1 : 0,
        }}
      />
    </div>
  );
};

export default Background;